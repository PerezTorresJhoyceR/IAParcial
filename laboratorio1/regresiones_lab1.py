# -*- coding: utf-8 -*-
"""regresiones_lab1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12mo2UzF1KWzj5zuRCK9tTJZMJY_v-XBA
"""

import numpy as np
import pandas as pd

# CARGA DE DATOS REALES
# Cargar el dataset desde tu archivo CSV
dataset = pd.read_csv('/content/drive/MyDrive/IA/calidad_de_vino.csv', delimiter=',')

# Verificar las columnas del dataset
print("Columnas del dataset:")
print(dataset.columns.tolist())
print(f"Forma del dataset: {dataset.shape}")
print("\nPrimeras 5 filas:")
print(dataset.head())

# Codificar la columna categórica "color" si existe
if 'color' in dataset.columns:
    dataset['color_blanco'] = (dataset['color'] == 'blanco').astype(int)
    dataset = dataset.drop('color', axis=1)
else:
    print("\nNota: No se encontró columna 'color' en el dataset")

print("\nDataset preparado:")
print(dataset.head())
print(f"Forma del dataset final: {dataset.shape}")

# Separar características (X) y variable objetivo (y)
# Buscar automáticamente la columna de calidad
columnas_calidad = [col for col in dataset.columns if 'calidad' in col.lower() or 'quality' in col.lower()]
if columnas_calidad:
    columna_calidad = columnas_calidad[0]
    print(f"Columna de calidad encontrada: {columna_calidad}")
else:
    # Si no encuentra, usar la última columna
    columna_calidad = dataset.columns[-1]
    print(f"Usando última columna como calidad: {columna_calidad}")

# Excluir también columna ID si existe
columnas_a_excluir = [columna_calidad]
columnas_id = [col for col in dataset.columns if 'id' in col.lower() or col.lower().startswith('botella')]
columnas_a_excluir.extend(columnas_id)

X = dataset.drop(columnas_a_excluir, axis=1).values
y = dataset[columna_calidad].values

# Convertir a tipo float
X = X.astype(float)
y = y.astype(float)

print(f"\nNúmero de características: {X.shape[1]}")
print(f"Número de muestras: {X.shape[0]}")

# Normalizar las características
X_mean = np.mean(X, axis=0)
X_std = np.std(X, axis=0)
X_std[X_std == 0] = 1  # Evitar división por cero

X_norm = (X - X_mean) / X_std

# Agregar columna de unos para el término de sesgo
m = X_norm.shape[0]
X_norm = np.concatenate([np.ones((m, 1)), X_norm], axis=1)

# Función para calcular theta con la ecuación normal
def ecuacion_normal(X, y):
    """
    Calcula los parámetros theta usando la ecuación normal.
    theta = (X^T * X)^(-1) * X^T * y
    """
    try:
        theta = np.linalg.inv(X.T @ X) @ X.T @ y
    except np.linalg.LinAlgError:
        # Si la matriz no es invertible, usar pseudoinversa
        theta = np.linalg.pinv(X.T @ X) @ X.T @ y
    return theta

# Calcular los parámetros theta
theta = ecuacion_normal(X_norm, y)

print(f"\nTheta calculado (ecuación normal):")
print(f"Término de sesgo: {theta[0]:.4f}")
caracteristicas_usadas = dataset.drop(columnas_a_excluir, axis=1).columns
for i, feature in enumerate(caracteristicas_usadas):
    print(f"{feature}: {theta[i+1]:.4f}")

# Función para hacer predicciones
def predecir_calidad(caracteristicas, theta, X_mean, X_std):
    """
    Predice la calidad del vino basada en sus características.
    """
    # Normalizar las características de entrada
    caracteristicas_norm = (caracteristicas - X_mean) / X_std

    # Agregar término de sesgo
    caracteristicas_norm = np.insert(caracteristicas_norm, 0, 1)

    # Calcular predicción
    prediccion = np.dot(caracteristicas_norm, theta)

    # Asegurar que esté en el rango válido (típicamente 0-10 para calidad de vino)
    return max(0, min(10, prediccion))

# Ejemplo de predicción con un nuevo vino (usando valores promedio como ejemplo)
nuevo_vino = np.mean(X, axis=0)  # Usar los valores promedio del dataset
nuevo_vino[0] = 7.2  # Modificar algunos valores como ejemplo

calidad_predicha = predecir_calidad(nuevo_vino, theta, X_mean, X_std)

print(f"\n--- PREDICCIÓN ---")
print(f"Características del nuevo vino (ejemplo):")
caracteristicas_nombres = dataset.drop(columnas_a_excluir, axis=1).columns
for i, nombre in enumerate(caracteristicas_nombres):
    print(f"  {nombre}: {nuevo_vino[i]:.3f}")

print(f"\nCalidad predicha: {calidad_predicha:.2f}")

# Evaluar el modelo con los datos de entrenamiento
predicciones_entrenamiento = []
for i in range(len(X)):
    pred = predecir_calidad(X[i], theta, X_mean, X_std)
    predicciones_entrenamiento.append(pred)

# Calcular error cuadrático medio
mse = np.mean((np.array(predicciones_entrenamiento) - y)**2)
rmse = np.sqrt(mse)

print(f"\n--- EVALUACIÓN DEL MODELO ---")
print(f"Error cuadrático medio (MSE): {mse:.4f}")
print(f"Raíz del error cuadrático medio (RMSE): {rmse:.4f}")

# Mostrar algunas predicciones vs valores reales
print(f"\nComparación predicciones vs valores reales:")
for i in range(min(5, len(y))):
    print(f"Muestra {i+1}: Real={y[i]:.1f}, Predicho={predicciones_entrenamiento[i]:.2f}")